# 무한스크롤 공부하고 구현해보자
무한스크롤을 페이지네이션과 같이 렌더링 최적화 기법중 하나이다. 오늘은 이것을 공부할 것 이다.
최근에 무한스크롤을 프로젝트에 적용할 일이 생겨서 이를 구현하면서 정리해야겠다고 생각했다.
먼저 무한스크롤을 구현을 알아보기 전에 무한스크롤이 정확히 뭔지 공부해보고 구현해보자  

## 무한스크롤 이란?  
사용자가 페이지를 스크롤할 때마다 추가 콘텐츠가 자동으로 로드되어, 사용자가 끊김 없이 콘텐츠를 계속해서 탐색할 수 있는 기능을 말한다.  
한번에 모든 데이터를 불러오지 않고 사용자가 스크롤 시 지속해서 데이터를 불러오기 때문에 앱 성능을 향상시킬 수 있는 기법이다.  
장점
- 보다 편리한 UX

단점
- 스크롤바가 현제데이터를 기준으로 표시되어 실제데이터의 스크롤바와 안맞을 수 있다.

## 무한스크롤을 구현하는 방법  
무한스크롤을 구현하는 여러가지 방법이 있다.   
대표적인 방법으로 옵저버를 활용하여 무한스크롤을 구현하는 방법이 있다.  
이는 스크롤뷰 하단에 옵저버를 배치하여 유저가 스크롤을 내리다 View에서 옵저버가 감지되면 추가데이터를 불러와서 렌더링하는 방식이다.
이러한 방법도 좋지만 나는 `FlatList`컴포넌트에 `onEndReached` 속성을 사용하여 무한스크롤을 구현할 것이다.
속성에 대해서 먼저 알아보겠다.

내가 사용할 속성들
- onEndReached: 유저가 리스트 끝에 도달하면 실행
- onEndReachedThreshold: 전체데이터를 기준에서 퍼센트로 onEndReached의 시점을 변경
- ListFooterComponent: 데이터 끝지점에 띄울 컴포넌트
ex: 
```tsx
<FlatList
  onEndReached={fetchData}  // 리스트 끝에 도달하면 fetchData함수 실행
  onEndReachedThreshold={0.1}  // 전체 리스트를 기준으로 끝에서 10% 지점에서 호출
  ListFooterComponent={loading ? <Loading /> : null} // 데이터 끝에서 띄워줄 로딩바
/>
```
이런식으로 FlatList를 사용하여 간단하게 무한스크롤을 구현할 수 있다.  
하지만 이러한 방식을 사용했을 때 문제를 하나 야기할 수 있을 것 같다.  
아직 테스트 해보진 않았지만 스크롤을 끝까지 내려 더 이상 가져올 데이터가 없으면 지속적으로 api를 호출하는 이슈가 생길 것 같았다.  
만약 이러한 이슈가 생긴다면 데이터가 없는 지 상태를 검증한 후 해당 상태로 api의 호출을 막게 해야한다.    
이러한 문제점을 검색해보니 hasMore 상태 관리를 사용하여 해결할 수 있을 것이다.  
```jsx
 const [hasMore, setHasMore] = useState(true);
```

위 코드처럼 hasMore 상태를 만들어 만약 빈배열이면 flase를 반환하고 해당 상태에 따라 api를 호출할지 말지 여부를 결정할 수 있다.
위 방법을 사용하면 기존 문제였던 빈배열시 지속적인 api 호출을 방지할 수 있다.
하지만 위 방법을 그대로 적용시키면 hasMore의 상태가 빈배열을 조회해서 false일 경우 이후 추가데이터가 생기더라도 상태는 여전히 false이기 때문에 이후데이터를 렌더링하지 않는다.
이 문제를 해결하기 위해 빈배열을 조회하여 hasMore의 상태가 false가 되면 유저에게 새로고침을 유도하는 방향을 고려하였다.
hasMore의 상태가 false시 새로고침 버튼이나, 최상단 리스트로 올리는 버튼을 만들어 새로고침을 을 유도할 수 있다.
