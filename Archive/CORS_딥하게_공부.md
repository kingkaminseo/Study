# CORS가 뭔데 아니 그전에 이게 왜 있는건데?

### CORS가 왜 있는거야 **년이
브라우저는 기본적으로 SOP 정책을 따르고 있다고 한다.  
> SOP(Same-Origin Policy)
 
SOP는 웹 생태계에서 다른 출처로의 리소스 요청을 제한하는 정책중 하나로,    
같은 출처의 리소스만 공유할 수 이도록 제한하는 정책이다.  
하지만 다른 출처의 API나 서드파티API 같은 경우 SOP 정책에 위반되기 때문에  
이를 방지하고자 CORS 정책이 탄생하였고 CORS 정책을 지킨 리소스 요청이 위반되지 않는다면  
정상적으로 리소스를 요청할 수 있게 해주겠다는 것이다.  

## CORS란?
> CORS(Cross-Origin Resource Sharing)  
  
CORS를 한국어로 직역하면 '교차 출처 리소스 공유'이다.  
CORS란 도메인이 다른 서버끼리 리소스를 주고 받을 때 보안을 위해 설정된 정책이라고 생각하면 된다.  
다른 타 웹서버에서 클라이언트로 데이터를 가져오려고 할 때 서버에서 CORS 허용 설정이 되어있지 않으면 접근이 거부된다.  
도메인이 다른 서버끼리 리소스를 주고받거나 프론트와 백엔드의 협업을 위해   
따로 서버를 뛰우게 되었을 때도 포트가 서로 달라 우리가 흔하게 보는 CORS위반 에러가 발생한다.   

## 출처는 뭘로 구분하나여?
![img1 daumcdn](https://github.com/user-attachments/assets/1c4344ea-fdbc-4f8c-97e8-d4769e88fa12)  
출처의 판단 기준은 도메인의 Scheme(프로토콜), Host(도메인), Port로 판단한다.  
위 3가지 중 하나라도 다르다면 corss-origin으로 판단한다.  

#### ex:

| same-origin                   | cross-origin                   |
|-------------------------------|--------------------------------|
| https://example.com:3000/main | https://example.com:3000/main |
| https://example.com:3000/search?name=minseo| https://example.com:8080/search?name=minseo |

위 기준으로 same-origin과 corss-origin을 비교할 수 있다.    
만약 포트가 없는 경우에는 브라우저의 독자적인 출처 비교로직을 따라간다고 한다.  
포트가 없는 서버의 경우 삼위일체였던 CORS출처 검증방식을 사용하기 애매해질 수 있다 판단하여  
해당 브라우저의 출처비교 로직을 따르는 것이다.  


## 언제 CORS를 검사하는거야?
CORS는 서버가 아니라 브라우저단에서 구현되어 있다.  
클라이언트에서 다른출처의 서버로 요청을 보내면 서버는 클라이언트에게 정상적으로 응답값을 보내준다.  
이후 브라우저가 응답값을 통해 분석하여 CORS 정책에 위반된다고 판단이 되면 해당 응답데이터를 파기한다.  
오 CORS는 브라우저단에서 검사하고 서버는 정상응답을 내려준다는 것을 배웠다.  
그럼 브라우저를 거치지 않고 서버끼리 통신할 경우 CORS가 없나?  
브라우저를 고치지 않고 서버끼리 통신할 경우 CORS 검증을 하지 않는다.  
때문에 프록시 서버를 두어 보안성을 향상시킬 수 있다.  
(프록시의 자세한건 풀지 않겠다.)   

## 동작 시나리오
기본적으로 웹 클라이언트에서 다른 출처 서버에 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청하는데   
이때 브라우저는 요청 헤더에 Origin이라는 필드생성하고 요청을 보내는 출처를 담아 함께 보낸다.  
이후 서버가 이 요청에 대한 응답으로 응답 헤더의 Access-Control-Allow-Origin이라는 값에 접근이 허용된 출처를 내려준다.  
이후 브라우저는 응답을 받고 요청을 보냈던 Origin 데이터와 서버가 보내준 Access-Control-Allow-Origin 응답값을 비교해본 후  
이 응답이 유효한지 아닌지를 결정한다.  
위 방식은 기본적인 방식이고 이외에도 여러가지 방식이 있다.  
여러 가지 방식중에서 가장 많이 쓰이는 `Preflight Request`에 대해 알아보려고 한다.  

## Preflight Request
 ![image](https://github.com/user-attachments/assets/162a9eb5-370d-422b-9ccb-4a8a52aa2aed)
위 사진은 preflight 시나리오의 시쿼스 다이어그램이다.  
Preflight 요청방식은 일반적으로 가장 많이 보이는 시나리오 중 하나이다.  
위 방식은 클라이언트에서 요청을 한번에 보내지 않고 예비요청과 본 요청으로 나누어서 서버에 요청한다.  
예비요청은 메인 요청을 보내기전 브라우저에서 예비요청을 리소스를 받아올 서버로 보내서 안전한지 확인하는 용도로 사용되고 있다.  
예비요청은 `OPTIONS` 메서드를 사용하고 있는데 FE개발자라면 많이 보았을 것이다. (나도 많이 봤음)  
예비요청을 받은 서버는 허용할 옵션들을 Response Header에 넣어 클라이언트에 응답을 보내준다.  
브라우저는 서버가 보낸 응답 정보로 허용되지 않은 요청인 경우 405 에러를 발생하고 메인 요청을 서버로 전송하지 않는다.  
만약 허용된 요청일 경우 메인 요청을 보낸다.  

- Access-Control-Allow-Origin
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers
- Access-Control-Max-Age

응답헤더로는 다음과 같은 정보를 보낸다.
Preflight Request 방식은 많은 리소스를 잡아 먹지만
서버에서 준 `Access-Control-Max-Age` 정보를 통해서 `Preflight Request`를 캐싱하여 효율을 높일 수 있다.
